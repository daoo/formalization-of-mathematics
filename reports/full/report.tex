\documentclass[a4paper]{article}
\usepackage[fixlanguage]{babelbib}
\usepackage[numbers,sort]{natbib}
\usepackage[swedish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{authblk}
\usepackage{fancyhdr}

\pagestyle{fancy}
\selectbiblanguage{swedish}

\title{Formalisering av Algoritmer och Matematiska Bevis}

\author[1]{Jesper Andersson}
\author[1]{Daniel Oom}
\author[1]{Niclas Ståhl}
\author[2]{Åsa Lideström}
\author[2]{Anders Sjöberg}
\affil[1]{Datateknik, Chalmers}
\affil[2]{Mattematik, Göteborgs Universitet}

\renewcommand\Authands{ och }

\date{\today}

\lhead{Formalisering av Algoritmer och Matematiska Bevis}
\rhead{Grupp 11}

\begin{document}
\begin{abstract}
Todo
\end{abstract}

\maketitle
\thispagestyle{empty}
\newpage
\tableofcontents
\newpage

\section{Inledning}
Formalisering av matematik

\subsection{Proof Assistant}
\subsection{Coq}
\subsection{Toom-Cook}

\section{Metod}

Målet med vårt projekt är att bevisa en algoritm i Coq med hjälp av SSReflect.
För att uppnå detta behöver vi först lära oss Coq och SSReflect. Vårt projekt
kan därför delas in i tre delar: inlärning, test, samt implementation och
bevis.

\subsection{Inlärning}
Den första delen av vårt projekt gick ut på att lära oss Coq och SSReflect. För
detta krävdes utbilndningsmaterial och eftersom bevisassistenter var helt nytt
för oss visste vi inte vad vi skulle leta efter. Men vår handledare hjälpte oss
att komma igång med kursmaterial från andra universitet och ett par artiklar:
\begin{itemize}
  \item Software Foundations
  \item Coq in a Hurry
  \item Coq Master
\end{itemize}
Detta material innhåller övningar som vi studerade huvudsaklingen enskilt och
sedan jämförde våra lösningar i gruppmöten.

När vi fått en grundläggande förståelse av Coq började vi ge oss in på
SSReflect. Samma arbetsgång användes som för Coq, övningar och inläsning fast
med ett annat, SSReflect-inriktat, material:
\begin{itemize}
  \item MAP Spring School organiserad av Inria
  \item SSReflect Tutorial
\end{itemize}
I detta skede började vi även också titta på och försöka förstå Toom-Cook.

\subsection{Test av Kunskaper}
Nästa del i arbetet var ett mer praktiskt test av vad vi lyckats lära oss.
Detta genom att bevisa en enklare algorithm, Karatsuba, i Coq och SSReflect.
Karatsuba är ett specialfall av Toom-Cook och vår handledare hade redan gjort
ett bevis och föreslog att vi också skulle göra det.

Bevisa Karatsuba. Implementation i Haskell.

\subsection{Implementation och Bevis}

\section{Resultat}

\bibliographystyle{plainnat}
\bibliography{report}
\nocite{*}

\appendix
\section{Karatsuba Proof}
\begin{verbatim}
Require Import ssreflect ssrfun ssrbool eqtype ssrnat div seq.
Require Import path choice fintype tuple finset ssralg poly polydiv.

(* Standard stuff to make Coq behave the way SSReflect wants *)
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensives.

(* Import necessary theory about rings and polynomial division *)
Import GRing.Theory Pdiv.Ring Pdiv.CommonRing Pdiv.RingMonic.

(* Open the correct scope so that 0, 1, + and * are interpreted correctly *)
Open Scope ring_scope.

(* Open a section *)
Section karatsuba.

(* Let R be a commutative ring, i.e. a structure where we have 0, 1, + and *
   that behave the way we expect and where multiplication is commutative *)
Variable R : comRingType.

(* Make p and q always have type polynomial over R so that we don't have to
   write it everywhere *)
Implicit Types p q : {poly R}.

(* Splitting of polynomials defined using polynomial division.
   rdivp is division and rmodp is modulus. *)
Definition split_poly n p := (rdivp p 'X^n, rmodp p 'X^n).

(* Main property of split_poly *)
Lemma split_polyP n p : p = (split_poly n p).1 * 'X^n + (split_poly n p).2.
Proof.
  by rewrite /split_poly -rdivp_eq // monicE lead_coefXn.
Qed.

Lemma div_mod_poly n p : p = rdivp p 'X^n * 'X^n + rmodp p 'X^n.
Proof.
  by apply rdivp_eq; rewrite monicE lead_coefXn.
Qed.

(* Recursive part of karatsuba multiplication. Parametrize by a natural number
   to make Coq realize that the code always terminate (this means that induction
   should be done on n in the correctness proof). *)
Fixpoint karatsuba_rec (n : nat) p q := match n with
  | 0%N   => p * q
  | n'.+1 =>
      let sp := size p in let sq := size q in
      if (sp <= 2) || (sq <= 2) then p * q else
        let m       := minn sp./2 sq./2 in
        let (p1,p2) := split_poly m p in
        let (q1,q2) := split_poly m q in
        let p1q1    := karatsuba_rec n' p1 q1 in
        let p2q2    := karatsuba_rec n' p2 q2 in
        let p12     := p1 + p2 in
        let q12     := q1 + q2 in
        let p12q12  := karatsuba_rec n' p12 q12 in
        p1q1 * 'X^(2 * m) + (p12q12 - p1q1 - p2q2) * 'X^m + p2q2
  end.

(* The final karatsuba function calls the recursive part with a "large enough
   number", i.e. the maximum of the degrees of the polynomials *)
Definition karatsuba p q := karatsuba_rec (maxn (size p) (size q)) p q.

Lemma karatsuba_split : forall p q,
  rdivp (R:=R) p 'X^(minn (size p)./2 (size q)./2) *
  rdivp (R:=R) q 'X^(minn (size p)./2 (size q)./2) *
  'X^(2 * minn (size p)./2 (size q)./2) +
  ((rdivp (R:=R) p 'X^(minn (size p)./2 (size q)./2) +
    rmodp (R:=R) p 'X^(minn (size p)./2 (size q)./2)) *
  (rdivp (R:=R) q 'X^(minn (size p)./2 (size q)./2) +
    rmodp (R:=R) q 'X^(minn (size p)./2 (size q)./2)) -
  rdivp (R:=R) p 'X^(minn (size p)./2 (size q)./2) *
  rdivp (R:=R) q 'X^(minn (size p)./2 (size q)./2) -
  rmodp (R:=R) p 'X^(minn (size p)./2 (size q)./2) *
  rmodp (R:=R) q 'X^(minn (size p)./2 (size q)./2)) *
  'X^(minn (size p)./2 (size q)./2) +
  rmodp (R:=R) p 'X^(minn (size p)./2 (size q)./2) *
  rmodp (R:=R) q 'X^(minn (size p)./2 (size q)./2) = p * q.
Proof.
  move=> p q.
  set d := minn (size p)./2 (size q)./2.

  set p1 := rdivp (R:=R) p 'X^d.
  set p2 := rmodp (R:=R) p 'X^d.
  set q1 := rdivp (R:=R) q 'X^d.
  set q2 := rmodp (R:=R) q 'X^d.

  have -> : ((p1 + p2) * (q1 + q2) = p1 * q1 + p1 * q2 + (p2 * q1 + p2 * q2))
    by rewrite mulrDl ?mulrDr.

  rewrite -?addrA.

  have -> : (p2 * q2 + (- (p1 * q1) - p2 * q2) = - (p1 * q1))
    by rewrite addrC -?addrA addNr addr0.

  have -> : (p1 * q1 + (p1 * q2 + (p2 * q1 - p1 * q1)) = p1 * q2 + p2 * q1)
    by rewrite addrC -?addrA addNr addr0 addrC.

  have -> : (p1 * q1 * 'X^(2 * d) = p1 * q1 * 'X^d * 'X^d)
    by rewrite mul2n -addnn exprD mulrA.

  rewrite ?addrA -mulrDl ?addrA.

  have extractp: (forall (a b c : {poly R}), a * b * 'X^d + a * c = a * (b * 'X^d + c)).
    by move=> a b c; rewrite -mulrA -mulrDr.
  rewrite extractp.

  rewrite -div_mod_poly.

  rewrite mulrDl -addrA extractp -div_mod_poly.
  by rewrite -mulrA (mulrC q 'X^d) mulrA -mulrDl -div_mod_poly.
Qed.

(* Correctness of the recursive part *)
Lemma karatsuba_recP : forall n p q, karatsuba_rec n p q = p * q.
Proof.
(* Some hints:

- The proof should be by induction on n.
- To handle the "if-then-else" do "case: ifP".
- It might be very useful to use the "set" tactic in order to make the goal
  more readable (i.e. to hide all rdivp and rmodp).
- As usual Search and looking in the files (ssralg.v and poly.v) is the way to
  find all the necessary lemmas.
*)
  by elim=> [ // | n IH p q ]; rewrite //= ?IH karatsuba_split; case: ifP.
Qed.

(* Correctness of karatsuba *)
Lemma karatsubaP p q : karatsuba p q = p * q.
Proof.
(* This proof should be very very easy now that you have proved the recursive
   part correct *)
  exact: karatsuba_recP.
Qed.

End karatsuba.
\end{verbatim}

\section{Toom-$n$ in Haskell}
\subsection{ToomCookNat.hs}
\begin{verbatim}
{-# LANGUAGE LambdaCase #-}
module ToomCookNat where

import Data.List
import Data.Ratio

data ToomCook = ToomCook
  { toomK :: Int
  , toomMat :: [[Integer]]
  , toomInvMat :: [[Rational]]
  }

matVecMul :: Num a => [[a]] -> [a] -> [a]
matVecMul mat vec = map (sum . zipWith (*) vec) mat

unsafeToInteger :: Rational -> Integer
unsafeToInteger r | denominator r == 1 = numerator r
                  | otherwise          = error $ show r

degree :: Integer -> Integer
degree = go 0
  where
    go acc 0 = acc
    go acc n = go (acc + 1) (n `div` 10)

baseExponent :: Int -> Integer -> Integer -> Integer
baseExponent k n m = 1 + max
  (degree n `div` fromIntegral k)
  (degree m `div` fromIntegral k)

split :: Int -> Integer -> Integer -> [Integer]
split k b = go k []
  where
    go 0  acc _ = acc
    go k' acc n = let (n', x') = n `divMod` b
                   in go (k' - 1) (x' : acc) n'

merge :: Integer -> [Integer] -> Integer
merge b = recompose b . reverse

evaluate :: [[Integer]] -> [Integer] -> [Integer]
evaluate mat vec = matVecMul mat (reverse vec)

interpolate :: [[Rational]] -> [Integer] -> [Integer]
interpolate mat = map unsafeToInteger . matVecMul mat . map toRational

recompose :: Integer -> [Integer] -> Integer
recompose b = snd . foldl' (\(b', sum) x -> (b * b', sum + b' * x)) (1, 0)

toomCook :: ToomCook -> Integer -> Integer -> Integer
toomCook t n m | n < 0 && m < 0 = toomCook t (abs n) (abs m)
               | n < 0          = negate $ toomCook t (abs n) m
               | m < 0          = negate $ toomCook t n (abs m)

               | n <= 100 || m <= 100 = n * m

               | otherwise =
  let b   = 10^(baseExponent (toomK t) n m)
      n'  = split (toomK t) b n
      m'  = split (toomK t) b m
      n'' = evaluate (toomMat t) n'
      m'' = evaluate (toomMat t) m'
      r   = zipWith (toomCook t) n'' m''
      r'  = interpolate (toomInvMat t) r
   in recompose b r'
\end{verbatim}

\subsection{Properties.hs}
\begin{verbatim}
module Properties where

import Test.QuickCheck
import ToomCookNat

genK :: Gen Int
genK = choose (2, 10)

genNum :: Gen Integer
genNum = choose (100000000, 999999999)

propToomCookCorrect :: ToomCook -> Property
propToomCookCorrect t = forAll genNum $ \n -> forAll genNum $ \m ->
  toomCook t n m == n * m

propSplitCorrect :: Property
propSplitCorrect = forAll genK $ \k -> forAll genNum $ \n ->
  let b = 10^baseExponent k n n in n == merge b (split k b n)
\end{verbatim}

\subsection{Examples.hs}
\begin{verbatim}
module Examples where

import Data.Ratio
import ToomCookNat

wikiSettings :: ToomCook
wikiSettings = ToomCook 3
  [ [ 1 , 0  , 0 ]
  , [ 1 , 1  , 1 ]
  , [ 1 , -1 , 1 ]
  , [ 1 , -2 , 4 ]
  , [ 0 , 0  , 1 ]
  ]
  [ [ 1    , 0   , 0   , 0    , 0  ]
  , [ 1%2  , 1%3 , -1  , 1%6  , -2 ]
  , [ -1   , 1%2 , 1%2 , 0    , -1 ]
  , [ -1%2 , 1%6 , 1%2 , -1%6 , 2  ]
  , [ 0    , 0   , 0   , 0    , 1  ]
  ]

test1Settings :: ToomCook
test1Settings = ToomCook 4
  [ [ 1 , 0  , 0 , 0  ]
  , [ 1 , 1  , 1 , 1  ]
  , [ 1 , -1 , 1 , -1 ]
  , [ 1 , -2 , 4 , -8 ]
  , [ 1 , 2  , 4 , 8  ]
  , [ 1 , 3  , 9 , 27 ]
  , [ 0 , 0  , 0 , 1  ]
  ]
  [ [ 1     , 0     , 0     , 0      , 0     , 0     , 0   ]
  , [ -1%3  , 1     , -1%2  , 1%20   , -1%4  , 1%30  , -12 ]
  , [ -5%4  , 2%3   , 2%3   , -1%24  , -1%24 , 0     , 4   ]
  , [ 5%12  , -7%12 , -1%24 , -1%24  , 7%24  , -1%24 , 15  ]
  , [ 1%4   , -1%6  , -1%6  , 1%24   , 1%24  , 0     , -5  ]
  , [ -1%12 , 1%12  , 1%24  , -1%120 , -1%24 , 1%120 , -3  ]
  , [ 0     , 0     , 0     , 0      , 0     , 0     , 1   ]
  ]

test2Settings :: ToomCook
test2Settings = ToomCook 2
  [ [ 1 , 0 ]
  , [ 1 , 1 ]
  , [ 0 , 1 ]
  ]
  [ [1  , 0 , 0  ]
  , [-1 , 1 , -1 ]
  , [0  , 0 , 1  ]
  ]
\end{verbatim}

\section{Toom-$n$ in Coq}
\begin{verbatim}
Require Import ssreflect ssrfun ssrbool eqtype ssrnat div seq matrix.
Require Import path choice fintype tuple finset ssralg poly polydiv bigop.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensives.

Import GRing.Theory Pdiv.Ring Pdiv.CommonRing Pdiv.RingMonic.
Open Scope ring_scope.

Section toomCook.

Variable R : comRingType.
Variable m : nat. (* Number of splits in Toom-m *)
Definition np : nat := m.*2 .-1. (* Number of evaluation points *)
Variable evaluation_mat : 'M[{poly R}]_(np, m).
Variable interpolation_mat : 'M[{poly R}]_np.
Implicit Types p q : {poly R}.

Definition exponent (k: nat) p q : nat :=
  maxn (divn (size p) k) (divn (size q) k) .+1.

(*
 * m is a k by 1 matrix
 * m(0, 0) = (p / x^0b) % x^b
 * m(1, 0) = (p / x^1b) % x^b
 * m(2, 0) = (p / x^2b) % x^b
 * m(3, 0) = (p / x^3b) % x^b
 * ...
*)

Definition split (n: nat) p : 'cV[{poly R}]_m :=
  \col_i rmodp (rdivp p 'X^(i * n)) 'X^n.

Definition evaluate (vec: 'cV[{poly R}]_m) : 'cV[{poly R}]_np :=
  (* TODO: vec must have correct order, in the haskell implementation we
   *       reverse the vector (list) *)
  evaluation_mat *m vec.

Definition interpolate (vec: 'cV[{poly R}]_np) : 'cV[{poly R}]_np :=
  interpolation_mat *m vec.

Definition recompose (n: nat) (vec: 'cV[{poly R}]_np) : {poly R} :=
  ((\row_i 'X^(i * n)) *m vec) ord0 ord0.

Fixpoint toom_cook_rec (n: nat) p q : {poly R} :=
  match n with
  | 0%N   => p * q
  | n'.+1 =>
    let e   := exponent m p q in
    let p'  := split e p in
    let q'  := split e q in
    let p'' := evaluate p' in
    let q'' := evaluate q' in
    let r   := \col_i (toom_cook_rec n' (p'' i ord0) (q'' i ord0)) in
    let r'  := interpolate r
     in recompose e r'
  end.

Definition toom_cook p q : {poly R} :=
  toom_cook_rec (maxn (size p) (size q)) p q.

End toomCook.
\end{verbatim}
\end{document}

% vim: set fdm=marker fmr=(fold),(end) :
