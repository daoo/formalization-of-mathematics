\documentclass[a4paper]{article}
\usepackage[fixlanguage]{babelbib}
\usepackage[numbers,sort]{natbib}
\usepackage[swedish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{a4wide}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{authblk}
\usepackage{fancyhdr}

\selectlanguage{swedish}

\newtheorem{theorem}{Sats}[section]
\newtheorem{definition}[theorem]{Definition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Korollarium}

\pagestyle{fancy}
\selectbiblanguage{swedish}

\title{Formalisering av Algoritmer och Matematiska Bevis}

\author[1]{Jesper Andersson}
\author[1]{Daniel Oom}
\author[1]{Niclas Ståhl}
\author[2]{Åsa Lideström}
\author[2]{Anders Sjöberg}
\affil[1]{Datateknik, Chalmers}
\affil[2]{Mattematik, Göteborgs Universitet}

\renewcommand\Authands{ och }

\date{\today}

\lhead{Formalisering av Algoritmer och Matematiska Bevis}
\rhead{Grupp 11}

\begin{document}
\begin{abstract}
Todo
\end{abstract}

\maketitle
\thispagestyle{empty}
\newpage
\tableofcontents
\newpage

\section{Inledning}
Formalisering av matematik

\subsection{Verktyg för formalisering av matematik}
Det finns många olika program och språk för att formallisera och bevisa
olika former av matematik eller logik. En sak som de flesta har gemensamt är
att de är uppbyggd på funktionella programmerings paradigmer.

\subsubsection{Agda}
Agda är utveckladat på chalmers och påminner till stor del om Haskell. Till
skillnad mot Coq så finns det inga inbyggda taktiker. Istället för att skriva
bevis med taktiker så skrivs bevisen på samma sätt som vanliga funktioner.
Detta gör att det är lättare att se att program och bevis är samma sak. Agda är
inte lika matematiskt inriktad som Coq utan används mer till att bevisa
korrekthet hos program. En fördel med Agda är att alla Unicode tecken är
tillåtna vilket gör det enkelt att skriva sina program och bevis på samma sätt
som man skulle göra det på paper.

\subsubsection{Z3}
Z3 är ett språk som har utvecklats av Microsoft för att förenkla och bevisa
olika theorem. Kan användas tillsammans med flera stora ickefunktionella språk
som Python,C och .NET.

\begin{itemize}
  \item Utvecklat av MIcrosoft
  \item ''Theorem prover''
  \item Används mest för att testa och verifiera program
\end{itemize}

\subsubsection{HOL-light}
HOL är en av de första teorem bevisarna och HOL-light som är en utveckling av
det används idag av Intel för att bevisa att vissa hårdvarukomponenter fungerar
korrekt.

\section{Metod}
Målet med vårt projekt är att bevisa en algoritm i Coq med hjälp av SSReflect.
För att uppnå detta behöver vi först lära oss Coq och SSReflect. Vårt projekt
kan därför delas in i tre delar: inlärning, test, samt implementation och
bevis.

\subsection{Inlärning}
Den första delen av vårt projekt gick ut på att lära oss Coq och SSReflect. För
detta krävdes utbilndningsmaterial och eftersom bevisassistenter var helt nytt
för oss visste vi inte vad vi skulle leta efter. Men vår handledare hjälpte oss
att komma igång med kursmaterial från andra universitet och ett par artiklar:
\begin{itemize}
  \item Software Foundations
  \item Coq in a Hurry
  \item Coq Master
\end{itemize}
Detta material innhåller övningar som vi studerade huvudsaklingen enskilt och
sedan jämförde våra lösningar i gruppmöten.

När vi fått en grundläggande förståelse av Coq började vi ge oss in på
SSReflect. Samma arbetsgång användes som för Coq, övningar och inläsning fast
med ett annat, SSReflect-inriktat, material:
\begin{itemize}
  \item MAP Spring School organiserad av Inria
  \item SSReflect Tutorial
\end{itemize}
I detta skede började vi även också titta på och försöka förstå Toom-Cook.

\subsection{Test av Kunskaper}
Nästa del i arbetet var ett mer praktiskt test av vad vi lyckats lära oss.
Detta genom att bevisa en enklare algorithm, Karatsuba, i Coq och SSReflect.
Karatsuba är ett specialfall av Toom-Cook och vår handledare hade redan gjort
ett bevis och föreslog att vi också skulle göra det.

Bevisa Karatsuba. Implementation i Haskell.

\subsection{Implementation och Bevis}

\section{Resultat}
\subsection{Definition av Toom - Cook m}
Låt R vara ett integritetsområde och låt $p, q \in R[x]$, där $p(x)= a_0 + a_1 x + ... + a_n x^n$ och
$q(x) = b_0 + b_1 x + ... + b_s x^s$, med $0 \leq s \leq n$. I detta stycke definierar vi Toom-Cook m $(p, q)$, där
$m \in \mathbb{N}$ och $m \geq 3$, som resultatet av algoritmen nedan.

\subsubsection{Gradkontroll}
Om $grad \; p = n \leq 2$, låt Toom-Cook $m (p, q) = p \cdot q$, annars gå till steg 2.

\subsubsection{Uppdelning}
Låt $b=\displaystyle \lfloor \frac{1 + grad \; p}{m}\rfloor + 1 = \lfloor \frac{1 + n}{m}\rfloor + 1$.
Låt för $f \in R[x] \; f / x^k$ beteckna kvoten vid division av $f$ med $x^k$, det vill säga $f/x^k = q$ om $f = q x^k + r$
och $r = 0$ eller $grad \;r \leq grad \; x^k = k$.
Nu definierar vi $u, v \in R[x][y]$. Låt $u(y)=u_0 + u_1 y + ... + u_{m-1} y^{m-1}$ där $u_k = p / x^{bk}$ mod $x^b$ och
 $v(y)=v_0 + v_1 y + ... + v_{m-1} y^{m-1}$ där $v_k = q / x^{bk}$ mod $x^b$. Vi vill att $u(x^b)=p(x)$ och $v(x^b)=q(x)$.

\subsubsection{Evaluering}
Nu ska vi beräkna $w = u \cdot v$. Vi gör detta genom att beräkna $w(\alpha_i)=u(\alpha_i) \cdot v(\alpha_i)$
för $d + 1$ punkter $\alpha_0, ...,  \alpha_d$, där $\alpha_i \in R$ och därmed $u(\alpha_i), v(\alpha_i) \in R[x]$
och $d = m - 1 + m -1 = 2m-2 \geq grad \; w = grad \; u + grad \; v$. Därefter bestäms koefficienterna i $w$ genom interpolation.

I detta steg beräknar vi $u(\alpha_i)$ och $v(\alpha_i)$. Låt

\begin{equation}
\label{eq:NAME}
V_e =
\begin{pmatrix}
  \alpha_0^0 & \alpha_0^1 & ... & \alpha_0^{m-1}\\
  \vdots & \vdots & & \vdots \\
  \alpha_d^0 & \alpha_d^1 & ... & \alpha_d^{m-1}
\end{pmatrix}.
\end{equation}
Då får vi
\begin{equation}
\label{eq:NAME2}
V_e \cdot
\begin{pmatrix}
  u_0\\
  \vdots \\
  u_{m-1}
\end{pmatrix}
 =
\begin{pmatrix}
 u(\alpha_0)\\
 \vdots \\
 u(\alpha_d)
\end{pmatrix}
\end{equation}
och motsvarande för $v$.

\subsubsection{Rekusiv multiplikation}
Vi beräknar $w(\alpha_i)=u(\alpha_i) \cdot v(\alpha_i)$ för n $= 0, ... , d$ rekursivt genom att anropa algoritmen
med $u(\alpha_i)$ och $v(\alpha_i)$ som argument.

\subsubsection{Interpolation}
Vi bestämmer koefficienterna i $w(y)=w_0 + w_1 + \ldots + w_d$ genom interpolation. Om

\begin{equation}
\label{eq:NAME3}
V_I =
\begin{pmatrix}
  \alpha_0^0 & \alpha_0^1 & ... & \alpha_0^d\\
  \vdots & \vdots & & \vdots \\
  \alpha_d^0 & \alpha_d^1 & ... & \alpha_d^d
\end{pmatrix}
\end{equation}

så är

\begin{equation}
\label{eq:NAME4}
V_I \cdot
\begin{pmatrix}
  w_0\\
  \vdots\\
  w_d
\end{pmatrix}
=
\begin{pmatrix}
  w(\alpha_0)\\
  \vdots\\
  w(\alpha_d)
\end{pmatrix}
\end{equation}

och därmed

\begin{equation}
\label{eq:NAME5}
\begin{pmatrix}
  w_0\\
  \vdots\\
  w_d
\end{pmatrix} =
V_I^{-1} \cdot
\begin{pmatrix}
  w(\alpha_0)\\
  \vdots\\
  w(\alpha_d)
\end{pmatrix}
\end{equation}

om $V_I$ är inverterbar. Eftersom $V_I$ är en Vandermondematris så är
\begin{equation}
 \label{eq:NAME6}
det \; V_I = \prod_{0 \leq i < j \leq d} (\alpha_i - \alpha_j)
\end{equation},

och $V_I$ är inverterbar om $det \; V_I$ är ett inverterbart element i $R$ [referens].

\subsubsection{Sammansättning}
Vi får slutligen det önskade resultatet $p(x) \cdot q(x)$ genom att evaluera $w$ i $x^b$.

\subsection{Bevis av algoritmens korrekthet}
I detta stycke visar vi att för $p, q \in R[x]$ så är $p \cdot q =$ Toom-Cook m $(p, q)$.

\begin{proposition}
 Antag att $R$ är ett integritetsområde och att $p, q \in R[x]$. Om det finns
$\alpha_0, ...,  \alpha_{2m-2} \in R$ så att $ \prod_{0 \leq i < j \leq d} (\alpha_i - \alpha_j)$
är inverterbar i $R$, så är

\begin{equation}
  \label{eq:name7}
  \text{Toom-Cook m} \; (p, q) =  p \cdot q.
\end{equation}

\end{proposition}

\begin{proof}
Vi visar propositionen med induktion över $grad \; p$.

Basfall. När $n = grad \; p \leq 2$ så gäller (\ref{eq:name7}) enligt steg 1 i algoritmen.

Induktionssteg. Antag att $p, q \in R[x]$, där $p(x)= a_0 + a_1 x + ... + a_n x^n$ och
$q(x) = b_0 + b_1 x + ... + b_s x^s$, med $0 \leq s \leq n$. Antag också att $n > 2$ och att (\ref{eq:name7}) gäller
för polynom av $grad \; < n$. Eftersom $n > 2$ så går vi vidare till steg 2 i algoritmen och skapar $u$ och $v$.
När detta är gjort evaluerar vi i steg 3 $u$ och $v$ i punkterna $\alpha_0, ...,  \alpha_{2m-2}$. I steg 4 anropar
vi Toom-Cook m med argumenten $u(\alpha_i) \cdot v(\alpha_i)$ för $i = 0, \ldots , 2m-2$. Eftersom $grad \; u(\alpha_i)$
och $grad \; v(\alpha_i) < n$ enligt lemma 2.2 så är Toom-Cook m $(u(\alpha_i), v(\alpha_i)) = u(\alpha_i) \cdot v(\alpha_i)$ enligt
induktionsantagnandet.
I steg 5 skall vi bestämma koefficienterna i $w(y)=u(y) \cdot v(y)$. Detta gör vi genom att lösa matrisekvationen (\ref{eq:NAME4})
Eftersom interpolationsmatrisen $V_I$ enligt antagande är inverterbar så ges koefficienterna entydigt av (\ref{eq:NAME5}).
I steg 6 evaluerar vi $w(y)$ i $x^b$. Lemma 2.3 ger att $u(x^b)=p(x)$ och att $v(x^b)=q(x)$. Då $w(y)=u(y) \cdot v(y)$ så är
$w(x^b)=u(x^b) \cdot v(x^b)=p(x) \cdot q(x)$.
\end{proof}

\begin{lemma}
 Antag att $p(x) \in R[x]$ och att $grad \; p \geq 1$. Antag också att $u(y)$ är definierad enligt steg 2 i algoritmen och att $\alpha \in R$.
Då är $grad \; u(\alpha) < grad \; p$.
\end{lemma}
\begin{proof}
 Eftersom $\alpha \in R$ så är $grad \; u(\alpha) = grad u_0 + u_1 \alpha + ... + u_{m-1}\alpha^{m-1} = max \; grad \; u_k$ där $k={0,1,...,m-1}$.
$u_k = p(x)/x^{xb}$ mod $x^b < b = \lfloor \frac{1 + n}{m}\rfloor + 1 < grad \; p(x) = n$ ty $n-b = $
\end{proof}

\begin{lemma}
 Antag att $p(x) \in R[x]$ och att $b$ och $u(y)$ är definierad enligt steg 2 i algoritmen. Då är $u(x^b)=p(x)$.
\end{lemma}
\begin{proof}


\begin{align*}
u(x^b) &= \sum_{i = 0}^{m-1} p(x)/x^{bi} \; (mod \; x^b) x^{bi} \\
&= \sum_{i = 0}^{m-2} p(x)/x^{bi} \; (mod \; x^b) x^{bi} + p(x)/x^{b(m-1)} \; (mod \; x^b) x^{b(m-1)}.
\end{align*}

Påstående 1. Den sista termen i $u$ kan skrivas om till $p(x)/x^{b(m-1)} x^{b(m-1)}$ eftersom $n - b(m-1) < b$.

Vi har att
\begin{align*}
 b - (n - b(m-1)) &= m b - n \\
&= m (\lfloor \frac{1 + n}{m}\rfloor + 1) - n \\
&= m( \frac{1 + n}{m} -\{ \frac{1 + n}{m}\} ) + m - n \\
&= 1 + n - m \{ \frac{1 + n}{m}\} + m - n \\
&= 1 + m(1 - \{ \frac{1 + n}{m}\}) > 0
\end{align*}
eftersom $0 \leq \{ k \} < 1$ för alla heltal $k$. Graden av $p(x)/x^{b(m-1)}$ är $n - b(m-1) < b$,
och därmed är $p(x)/x^{b(m-1)} \; mod \; x^b = p(x)/x^{b(m-1)}$, vilket visar Påstående 1. Så
\begin{align*}
u(x^b) &= \sum_{i = 0}^{m-2} p(x)/x^{bi} \; (mod \; x^b) x^{bi} + p(x)/x^{b(m-1)} \; x^{b(m-1)}.
\end{align*}
\end{proof}

\bibliographystyle{plainnat}
\bibliography{report}
\nocite{*}

\appendix
\section{Karatsuba Proof}
\begin{verbatim}
Require Import ssreflect ssrfun ssrbool eqtype ssrnat div seq.
Require Import path choice fintype tuple finset ssralg poly polydiv.

(* Standard stuff to make Coq behave the way SSReflect wants *)
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensives.

(* Import necessary theory about rings and polynomial division *)
Import GRing.Theory Pdiv.Ring Pdiv.CommonRing Pdiv.RingMonic.

(* Open the correct scope so that 0, 1, + and * are interpreted correctly *)
Open Scope ring_scope.

(* Open a section *)
Section karatsuba.

(* Let R be a commutative ring, i.e. a structure where we have 0, 1, + and *
   that behave the way we expect and where multiplication is commutative *)
Variable R : comRingType.

(* Make p and q always have type polynomial over R so that we don't have to
   write it everywhere *)
Implicit Types p q : {poly R}.

(* Splitting of polynomials defined using polynomial division.
   rdivp is division and rmodp is modulus. *)
Definition split_poly n p := (rdivp p 'X^n, rmodp p 'X^n).

(* Main property of split_poly *)
Lemma split_polyP n p : p = (split_poly n p).1 * 'X^n + (split_poly n p).2.
Proof.
  by rewrite /split_poly -rdivp_eq // monicE lead_coefXn.
Qed.

Lemma div_mod_poly n p : p = rdivp p 'X^n * 'X^n + rmodp p 'X^n.
Proof.
  by apply rdivp_eq; rewrite monicE lead_coefXn.
Qed.

(* Recursive part of karatsuba multiplication. Parametrize by a natural number
   to make Coq realize that the code always terminate (this means that induction
   should be done on n in the correctness proof). *)
Fixpoint karatsuba_rec (n : nat) p q := match n with
  | 0%N   => p * q
  | n'.+1 =>
      let sp := size p in let sq := size q in
      if (sp <= 2) || (sq <= 2) then p * q else
        let m       := minn sp./2 sq./2 in
        let (p1,p2) := split_poly m p in
        let (q1,q2) := split_poly m q in
        let p1q1    := karatsuba_rec n' p1 q1 in
        let p2q2    := karatsuba_rec n' p2 q2 in
        let p12     := p1 + p2 in
        let q12     := q1 + q2 in
        let p12q12  := karatsuba_rec n' p12 q12 in
        p1q1 * 'X^(2 * m) + (p12q12 - p1q1 - p2q2) * 'X^m + p2q2
  end.

(* The final karatsuba function calls the recursive part with a "large enough
   number", i.e. the maximum of the degrees of the polynomials *)
Definition karatsuba p q := karatsuba_rec (maxn (size p) (size q)) p q.

Lemma karatsuba_split : forall p q,
  rdivp (R:=R) p 'X^(minn (size p)./2 (size q)./2) *
  rdivp (R:=R) q 'X^(minn (size p)./2 (size q)./2) *
  'X^(2 * minn (size p)./2 (size q)./2) +
  ((rdivp (R:=R) p 'X^(minn (size p)./2 (size q)./2) +
    rmodp (R:=R) p 'X^(minn (size p)./2 (size q)./2)) *
  (rdivp (R:=R) q 'X^(minn (size p)./2 (size q)./2) +
    rmodp (R:=R) q 'X^(minn (size p)./2 (size q)./2)) -
  rdivp (R:=R) p 'X^(minn (size p)./2 (size q)./2) *
  rdivp (R:=R) q 'X^(minn (size p)./2 (size q)./2) -
  rmodp (R:=R) p 'X^(minn (size p)./2 (size q)./2) *
  rmodp (R:=R) q 'X^(minn (size p)./2 (size q)./2)) *
  'X^(minn (size p)./2 (size q)./2) +
  rmodp (R:=R) p 'X^(minn (size p)./2 (size q)./2) *
  rmodp (R:=R) q 'X^(minn (size p)./2 (size q)./2) = p * q.
Proof.
  move=> p q.
  set d := minn (size p)./2 (size q)./2.

  set p1 := rdivp (R:=R) p 'X^d.
  set p2 := rmodp (R:=R) p 'X^d.
  set q1 := rdivp (R:=R) q 'X^d.
  set q2 := rmodp (R:=R) q 'X^d.

  have -> : ((p1 + p2) * (q1 + q2) = p1 * q1 + p1 * q2 + (p2 * q1 + p2 * q2))
    by rewrite mulrDl ?mulrDr.

  rewrite -?addrA.

  have -> : (p2 * q2 + (- (p1 * q1) - p2 * q2) = - (p1 * q1))
    by rewrite addrC -?addrA addNr addr0.

  have -> : (p1 * q1 + (p1 * q2 + (p2 * q1 - p1 * q1)) = p1 * q2 + p2 * q1)
    by rewrite addrC -?addrA addNr addr0 addrC.

  have -> : (p1 * q1 * 'X^(2 * d) = p1 * q1 * 'X^d * 'X^d)
    by rewrite mul2n -addnn exprD mulrA.

  rewrite ?addrA -mulrDl ?addrA.

  have extractp: (forall (a b c : {poly R}), a * b * 'X^d + a * c = a * (b * 'X^d + c)).
    by move=> a b c; rewrite -mulrA -mulrDr.
  rewrite extractp.

  rewrite -div_mod_poly.

  rewrite mulrDl -addrA extractp -div_mod_poly.
  by rewrite -mulrA (mulrC q 'X^d) mulrA -mulrDl -div_mod_poly.
Qed.

(* Correctness of the recursive part *)
Lemma karatsuba_recP : forall n p q, karatsuba_rec n p q = p * q.
Proof.
(* Some hints:

- The proof should be by induction on n.
- To handle the "if-then-else" do "case: ifP".
- It might be very useful to use the "set" tactic in order to make the goal
  more readable (i.e. to hide all rdivp and rmodp).
- As usual Search and looking in the files (ssralg.v and poly.v) is the way to
  find all the necessary lemmas.
*)
  by elim=> [ // | n IH p q ]; rewrite //= ?IH karatsuba_split; case: ifP.
Qed.

(* Correctness of karatsuba *)
Lemma karatsubaP p q : karatsuba p q = p * q.
Proof.
(* This proof should be very very easy now that you have proved the recursive
   part correct *)
  exact: karatsuba_recP.
Qed.

End karatsuba.
\end{verbatim}

\section{Toom-$n$ in Haskell}
\subsection{ToomCookNat.hs}
\begin{verbatim}
{-# LANGUAGE LambdaCase #-}
module ToomCookNat where

import Data.List
import Data.Ratio

data ToomCook = ToomCook
  { toomK :: Int
  , toomMat :: [[Integer]]
  , toomInvMat :: [[Rational]]
  }

matVecMul :: Num a => [[a]] -> [a] -> [a]
matVecMul mat vec = map (sum . zipWith (*) vec) mat

unsafeToInteger :: Rational -> Integer
unsafeToInteger r | denominator r == 1 = numerator r
                  | otherwise          = error $ show r

degree :: Integer -> Integer
degree = go 0
  where
    go acc 0 = acc
    go acc n = go (acc + 1) (n `div` 10)

baseExponent :: Int -> Integer -> Integer -> Integer
baseExponent k n m = 1 + max
  (degree n `div` fromIntegral k)
  (degree m `div` fromIntegral k)

split :: Int -> Integer -> Integer -> [Integer]
split k b = go k []
  where
    go 0  acc _ = acc
    go k' acc n = let (n', x') = n `divMod` b
                   in go (k' - 1) (x' : acc) n'

merge :: Integer -> [Integer] -> Integer
merge b = recompose b . reverse

evaluate :: [[Integer]] -> [Integer] -> [Integer]
evaluate mat vec = matVecMul mat (reverse vec)

interpolate :: [[Rational]] -> [Integer] -> [Integer]
interpolate mat = map unsafeToInteger . matVecMul mat . map toRational

recompose :: Integer -> [Integer] -> Integer
recompose b = snd . foldl' (\(b', sum) x -> (b * b', sum + b' * x)) (1, 0)

toomCook :: ToomCook -> Integer -> Integer -> Integer
toomCook t n m | n < 0 && m < 0 = toomCook t (abs n) (abs m)
               | n < 0          = negate $ toomCook t (abs n) m
               | m < 0          = negate $ toomCook t n (abs m)

               | n <= 100 || m <= 100 = n * m

               | otherwise =
  let b   = 10^(baseExponent (toomK t) n m)
      n'  = split (toomK t) b n
      m'  = split (toomK t) b m
      n'' = evaluate (toomMat t) n'
      m'' = evaluate (toomMat t) m'
      r   = zipWith (toomCook t) n'' m''
      r'  = interpolate (toomInvMat t) r
   in recompose b r'
\end{verbatim}

\subsection{Properties.hs}
\begin{verbatim}
module Properties where

import Test.QuickCheck
import ToomCookNat

genK :: Gen Int
genK = choose (2, 10)

genNum :: Gen Integer
genNum = choose (100000000, 999999999)

propToomCookCorrect :: ToomCook -> Property
propToomCookCorrect t = forAll genNum $ \n -> forAll genNum $ \m ->
  toomCook t n m == n * m

propSplitCorrect :: Property
propSplitCorrect = forAll genK $ \k -> forAll genNum $ \n ->
  let b = 10^baseExponent k n n in n == merge b (split k b n)
\end{verbatim}

\subsection{Examples.hs}
\begin{verbatim}
module Examples where

import Data.Ratio
import ToomCookNat

wikiSettings :: ToomCook
wikiSettings = ToomCook 3
  [ [ 1 , 0  , 0 ]
  , [ 1 , 1  , 1 ]
  , [ 1 , -1 , 1 ]
  , [ 1 , -2 , 4 ]
  , [ 0 , 0  , 1 ]
  ]
  [ [ 1    , 0   , 0   , 0    , 0  ]
  , [ 1%2  , 1%3 , -1  , 1%6  , -2 ]
  , [ -1   , 1%2 , 1%2 , 0    , -1 ]
  , [ -1%2 , 1%6 , 1%2 , -1%6 , 2  ]
  , [ 0    , 0   , 0   , 0    , 1  ]
  ]

test1Settings :: ToomCook
test1Settings = ToomCook 4
  [ [ 1 , 0  , 0 , 0  ]
  , [ 1 , 1  , 1 , 1  ]
  , [ 1 , -1 , 1 , -1 ]
  , [ 1 , -2 , 4 , -8 ]
  , [ 1 , 2  , 4 , 8  ]
  , [ 1 , 3  , 9 , 27 ]
  , [ 0 , 0  , 0 , 1  ]
  ]
  [ [ 1     , 0     , 0     , 0      , 0     , 0     , 0   ]
  , [ -1%3  , 1     , -1%2  , 1%20   , -1%4  , 1%30  , -12 ]
  , [ -5%4  , 2%3   , 2%3   , -1%24  , -1%24 , 0     , 4   ]
  , [ 5%12  , -7%12 , -1%24 , -1%24  , 7%24  , -1%24 , 15  ]
  , [ 1%4   , -1%6  , -1%6  , 1%24   , 1%24  , 0     , -5  ]
  , [ -1%12 , 1%12  , 1%24  , -1%120 , -1%24 , 1%120 , -3  ]
  , [ 0     , 0     , 0     , 0      , 0     , 0     , 1   ]
  ]

test2Settings :: ToomCook
test2Settings = ToomCook 2
  [ [ 1 , 0 ]
  , [ 1 , 1 ]
  , [ 0 , 1 ]
  ]
  [ [1  , 0 , 0  ]
  , [-1 , 1 , -1 ]
  , [0  , 0 , 1  ]
  ]
\end{verbatim}

\section{Toom-$n$ in Coq}
\begin{verbatim}
Require Import ssreflect ssrfun ssrbool eqtype ssrnat div seq matrix.
Require Import path choice fintype tuple finset ssralg poly polydiv bigop.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensives.

Import GRing.Theory Pdiv.Ring Pdiv.CommonRing Pdiv.RingMonic.
Open Scope ring_scope.

Section toomCook.

Variable R : comRingType.
Variable m : nat. (* Number of splits in Toom-m *)
Definition np : nat := m.*2 .-1. (* Number of evaluation points *)
Variable evaluation_mat : 'M[{poly R}]_(np, m).
Variable interpolation_mat : 'M[{poly R}]_np.
Implicit Types p q : {poly R}.

Definition exponent (k: nat) p q : nat :=
  maxn (divn (size p) k) (divn (size q) k) .+1.

(*
 * m is a k by 1 matrix
 * m(0, 0) = (p / x^0b) % x^b
 * m(1, 0) = (p / x^1b) % x^b
 * m(2, 0) = (p / x^2b) % x^b
 * m(3, 0) = (p / x^3b) % x^b
 * ...
*)

Definition split (n: nat) p : 'cV[{poly R}]_m :=
  \col_i rmodp (rdivp p 'X^(i * n)) 'X^n.

Definition evaluate (vec: 'cV[{poly R}]_m) : 'cV[{poly R}]_np :=
  (* TODO: vec must have correct order, in the haskell implementation we
   *       reverse the vector (list) *)
  evaluation_mat *m vec.

Definition interpolate (vec: 'cV[{poly R}]_np) : 'cV[{poly R}]_np :=
  interpolation_mat *m vec.

Definition recompose (n: nat) (vec: 'cV[{poly R}]_np) : {poly R} :=
  ((\row_i 'X^(i * n)) *m vec) ord0 ord0.

Fixpoint toom_cook_rec (n: nat) p q : {poly R} :=
  match n with
  | 0%N   => p * q
  | n'.+1 =>
    let e   := exponent m p q in
    let p'  := split e p in
    let q'  := split e q in
    let p'' := evaluate p' in
    let q'' := evaluate q' in
    let r   := \col_i (toom_cook_rec n' (p'' i ord0) (q'' i ord0)) in
    let r'  := interpolate r
     in recompose e r'
  end.

Definition toom_cook p q : {poly R} :=
  toom_cook_rec (maxn (size p) (size q)) p q.

End toomCook.
\end{verbatim}
\end{document}

% vim: set fdm=marker fmr=(fold),(end) :
