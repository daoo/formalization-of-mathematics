\subsection{Den formella algoritmen}
I det här kapitlet förklaras hur beviset av Toom-Cook, som gjorts i SSReflect,
fungerar och överrenstämmer med pappersbeviset. Hela implementation ligger som
ett appendix, !!!!!!!!!.

Algoritmen är implementerad med en rad små funktioner och sedan en rekursiv
del, där den rekursiva delen är Toom-Cook-algoritmen. Till en början kommer
alltså många variabler, definitioner och antaganden radas upp, som vi har
försökt att ge så självförklarande namn som möjligt.
\begin{lstlisting}
Variable R : idomainType.
Implicit Types p q : {poly R}.
\end{lstlisting}
Till att börja med skapas själva integritetsområdet, den variabeln kallas för
R. Därefter skapas två variabler p och q av typen poly R, alltså $R[x]$. Dessa
deklareras även implicit vilket innebär att när p och q användes så behövs inte
typen anges igen.

Här definieras variabler som är av typen nat, naturliga tal, som beror på
antalet splittar av polynomen som görs.
\begin{lstlisting}
Variable number_splits : nat.
Definition m : nat := number_splits.
Definition number_points := (2 * m) .-1.
\end{lstlisting}
Som i pappers algoritmen är m variabeln från Toom-Cook-$m$ och
\C{number_points} är antalet interpolationspunkter.
Interpolationspunkterna sparas i en kolonnvektor och är typen poly R, vilket
skiljer sig från pappers algoritmen. Det var viktigt att punkterna tillhörde R
i pappers algoritmen för att induktionsantagandet över graden skulle kunna
appliceras, läs !!!!!!!!!!!!, men i beviset i SSReflect så görs induktion över
en annan variabel så det problemet uppstår aldrig. Algoritmen blir dock
snabbare om interpolationspunkterna tillhör R eller är av låg grad i $R[x]$,
läs !!!!!!!!!!.
\begin{lstlisting}
Variable inter_points : 'cV[{poly R}]_(number_points).
Hypothesis m_neq_0 : 0 < m.
\end{lstlisting}
I pappers algoritmen har vi som antagande att m är större än 3. !!!!!!!!!!!!!!!
\begin{lstlisting}
Definition V_e : 'M[{poly R}]_(number_points, m) :=
  \matrix_(i < number_points, j < m) ((inter_points i 0))^+j.
\end{lstlisting}
Här definieras evalueringsmatrisen \C{V_e}. Den ska ha dimension
\C{number_points x m} med element av typen poly R. Argumentet \C{(i <
number_points, j < m)} säger just att matrisen är av dimensionen
\C{number_points x m}. Det andra argumentet \C{((inter_points i 0))^+j}
bestämmer vilket element som ska vara på plats \C{(i,j)} i matrisen, vilket i
det här fallet är det \C{i}:te elementet ur kolonnvektorn \C{inter_points}
upphöjt i \C{j}, vilket då blir en Vandermondematris.
\begin{lstlisting}
Definition V_I : 'M[{poly R}]_(number_points) :=
  \matrix_(i < number_points, j < number_points) ((inter_points i 0))^+j.
\end{lstlisting}
Här definieras interpolationsmatrisen på motsvarade sätt som
evalueringsmatrisen, skillnaden är att det blir en matris av dimension
\C{number_points * number_points} istället.
\begin{lstlisting}
Definition exponent (m: nat) p q : nat :=
  (maxn (divn (size p) m) (divn (size q) m)).+1.
\end{lstlisting}
Här definieras exponent som tar ett naturligt tal m som inparameter och ger ett
naturligt tal som utparameter. Om inparametern är värdet av m i Toom-Cook-m så
motsvarar det här b i pappers algoritmen, läs !!!!!, eftersom size tar graden
av polynomet + 1, divn är heltalsdivision och maxn tar fram det största av två
tal.
\begin{lstlisting}
Definition split (n b: nat) p : {poly {poly R}} :=
  \poly_(i < n) rmodp (rdivp p 'X^(i * b)) 'X^b.
\end{lstlisting}
Split tar två naturliga tal som inparametrar och avger typen \C{\{poly \{poly
R\}\}}, alltså $R[x][y]$. De två funktionerna rmodp och rdivp är redan
implementerade i SSReflects bibliotek och motsvarar exakt vår definition av
modulusräkning och polynomdivision, läs !!!!!!!!!!.
\begin{lstlisting}
Definition evaluate (u: {poly {poly R}}) : 'cV[{poly R}]_(number_points) :=
  V_e *m (poly_rV u)^T.
Definition interpolate (u: 'cV[{poly R}]_(number_points)) : {poly {poly R}} :=
  rVpoly (invmx V_I *m u)^T.
\end{lstlisting}
Här definieras själva matrismultiplikationerna, läs ..... och ...... Funktionen
\C{poly_rV} gör ett polynom u, av typ poly poly R, till en radvektor där varje
gradtal av polynoment placeras in på respektive rad, och sedan transponeras
vektorn.
\begin{lstlisting}
Definition recompose (b: nat) (w: {poly {poly R}}) : {poly R} :=
  w.['X^b].
\end{lstlisting}
Steg 4 i Toom-Cook är en rekusiv del och därmed behövs en rekusiv funktion,
nämligen Fixpoint för att kunna stega igenom hela algoritmen. I pappers
algoritmen slutar rekusionen när graden har blivit tillräckligt låg och då
utförs direktmultiplikation. Coq behöver få bevisat att rekusion terminar så
istället för att visa att graden sjunker för varje steg så skickas ett
naturligt tal n med som inparameter som minskar vid varje rekusion och slutar
när n är lika med noll och då utförs direkt multiplikation eller när graden har
blivit mindre än 2 på någotdera av polynomen. Så för att visa att Toom-Cook
fungerar så måste algoritmen funka för alla n.

Funktionen match kollar om n är lika med 0 i så fall retunera p gånger q eller
om den är en efterföljare till något till tal.
\begin{lstlisting}
Fixpoint toom_cook_rec (n: nat) p q : {poly R} :=
  match n with
  | 0%N => p * q
  | n'.+1 => if (size p <= 2) || (size q <= 2) then p * q else
        let b := exponent m p q in
        let u := split m b p in
        let v := split m b q in
        let u_a := evaluate u in
        let v_a:= evaluate v in
        let w_a := \col_i toom_cook_rec n' (u_a i 0) (v_a i 0) in
        let w := interpolate w_a
         in recompose b w
  end.
\end{lstlisting}
Här beskrivs det huvudsakliga resultatet av projektet: den formella
implementationen och beviset av Toom-Cook i Coq/Ssreflect. Den fungerar också
som en illustration på hur definitioner och bevis ser ut och fungerar i
Coq/Ssreflect. De viktigaste funktionerna och lemmana till algoritmen
presenteras. Den fullständiga koden finns i APPENDIX X.

