Under senare år har några mycket långa och komplexa matematiska bevis
presenterats. Vissa bevis har också byggt på en mycket omfattande analys av
tusentals fall utförd av datorprogram. Det är mycket tidsödande och svårt, om
ens praktiskt möjligt att för hand kontrollera varje steg ett sådant bevis. Få
matematiker har tid, lust och den speciella kompetensen inom just det specifika
matematiska området som gör att de kan eller vill att ägna år åt att
kontrollera att ett sådant bevis är korrekt. Dessutom finns risken för att ett
fel i ett bevis ändå inte upptäcks vid kontroll om beviset är hundratals- eller
tusentals sidor långt.\cite{harrison2008formal}

Bevisassistenter, datorsystem för att formalisera och verifiera varje logiskt
steg i bevis, kan användas för att kontrollera bevis och därmed öka tilltron
till att de är korrekta och minska risken för att de innehåller fel.

Fyrfärgssatsen\cite{gonthier2008formal} och Feit-Thompsons
sats\cite{aschbacher2004status} är två exempel på satser vars bevis har
formaliserats och kontrollerats i bevisassistenter. För att kunna kontrollera
själva bevisen har också all den matematik som bevisen bygger på formaliserats.
%Lite mer om fyrfärgssatsen här?
%Lite mer om Odd order theorem här?

De verktyg som används vid formalisering och datorverifiering kan även användas
för att verifiera programkod. Formella metoder är således intressant för både
för programmerare och matematiker.
% Niclas: Den här meningen säger väldigt lite. Varför??
Dagens stora och komplexa programvaror skulle kunna utnyttja formella metoder.
%)
Det kan också vara användbart i
kritiska system, till exempel medicinsk utrustning,  där det inte får bli fel
eller i system som inte kan uppdateras i efterhand som hårvarunära mjukvara
på ROM-minnen. De mest använda metoderna idag för
att kontrollera kod bygger på att testa om koden ger korrekt resultat för olika
indata. På detta sätt har man en chans att upptäcka om koden innehåller fel,
men det visar inte att koden saknar fel eftersom det i många fall är omöjligt
att testa alla kombinationer av indata.
% Niclas: + Svårt/Krävande att hitta kända resultat?
Formella metoder skulle i dessa fall
kunna användas till att garantera korrekthet hos koden.

Matematisk programvara som MATLAB spelar en stor roll för beräkningar inom
forskning och industri och det finns därmed ett stort intresse av att de är
% Niclas: känns som det kan finnas bättre ord än buggfria
pålitliga. De är dock inte buggfria. Ett sätt att göra dem mer pålitliga skulle
vara att formalisera de ingående algoritmerna och visa att de är korrekt
implementerade.\cite{mortberg2012}

Vårt projekt går ut på att lära oss formalisering med bevisassistenten \coq och
sedan formalisera och bevisa en matematisk algoritm i \coq.

\section{Vad är en bevisassistent?}
En bevisassisten är ett datorsystem som låter användaren
sätta upp matematiska teorier, definera egenskaper och utföra logiska
resonemang. I bevisassistenter ingår inte automatiska teorembevisare som
med hjälp av formulerade regler kan lösa vissa sorters bevis automatiskt.

Det är inte bara inom matematiken som bevisassistenter kan användas utan
även inom datavetenskap där man kan formulera program matematiskt och sedan
bevisa deras korrekthet. När man bevisar något i en bevisassisten så gör
man ofta beviset på papper först och sen översätter man pappersbeviset till
datorn. Bevisassistenten kontrollerar då att alla stegen i beviset är korrekt.
Det låter kanske som om en bevisassisten inte är till så stor hjälp om man
måste bevisa allt på papper först men dels kan pappersbeviset läggas på en
högre abstraktionsnivå och bevisassistenten kan även hitta slarvfel och
felaktiga antaganden. Ett bevis som gjort i en bevisassistent ger
därför en viss trovärdighet och det är lättare att övertyga resten av värden
att ens bevis är korrekta om de är formaliserat i en bevisassistent.

\section{Bevisassistent och programmeringsspråket Coq}
Formalisering är ett aktivt forskningsområde och det finns flertalet
datorverktyg för formalisering och verifiering av formella bevis som är under
aktiv utveckling. Vi har valt att använda verktyget Coq. Coq är ett
beroenedetypat funktionellt programmeringsspråk inte helt olikt Haskell. Men
till skillnad från Haskell är Coq även en \emph{interaktiv} bevisassistent som
kan användas till att utveckla formella bevis. Viktigt att notera här är att
Coq är interaktivt, det vill säga Coq bevisar inget automatiskt utan man måste
själv styra varje logiskt steg i bevisen. Program och bevis som är skrivna i
Coq går att exportera till Haskell,OCaml and Scheme vilket gör att man kan
skriva och bevisa de mest kritiska delarna i ett program och sedan exportera det
och köra det tillsammas med icke bevisad kod i till exempel Haskell.

\section{Multiplikation av polynom}
Vi har valt att implementera och bevisa Toom-Cook algoritmen för multiplikation
av polynom. Toom-Cook är generell och fungerar för polynom, men anledningen
till att den är intressant är att heltal är ett specialfall av polynom där
basen är känd. Vidare är Toom-Cook snabbare för väldigt stora polynom än den
multiplikationsmetoden man lär sig i grundskolan som vi kallar lång
multiplikation. Det finns även en annan algoritm för polynommultiplikation som
heter Karatsuba som också är snabbare än lång multiplikation och även enklare
än Toom-Cook. Men den är redan formaliserad av vår handledare och därför är det
mer intressant att formalisera Toom-Cook.

\section{Mål}
Målet med vårat projekt är således att lära oss hur man använder Coq och dess
tillägg SSReflect. Vidare skall vi också använda dessa verktyg för att
formalisera ett bevis av Toom-Cook algoritmen. Den här rapporten presenterar
våra resultat och diskuterar hur bevisassistenter kan användas.
