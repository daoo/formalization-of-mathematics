Under senare år har några mycket långa och komplexa matematiska bevis
presenterats. Några av dem har också byggt på en mycket omfattande analys av
tusentals fall utförda av datorprogram. Det är mycket tidsödande och svårt, om
ens praktiskt möjligt att för hand kontrollera varje steg i ett sådant bevis.
Få matematiker har tid, lust och den speciella kompetensen inom just det
specifika matematiska området för att kunna eller vilja ägna år åt att
kontrollera korrektheten hos ett sådant bevis. Dessutom finns risken att ett
fel i ett bevis ändå inte upptäcks vid kontroll om beviset är hundratals- eller
tusentals sidor långt\cite{harrison2008formal}.

Bevisassistenter är datorsystem för att formalisera och verifiera varje logiskt
steg i bevis som kan användas för att kontrollera bevis och därmed minimera
risken för att bevisen innehåller fel och öka tilltron till att de är korrekta.

Fyrfärgssatsen\cite{gonthier2008formal} och Feit-Thompsons
sats\cite{aschbacher2004status} är två exempel på satser vars bevis har
formaliserats och kontrollerats i bevisassistenter. Fyrfärgssatsen säger att
varje karta kan färgläggas med fyra färger så att inga regioner med gemensam
gräns får samma färg. Det ursprungliga beviset var över hundra sidor långt och
byggde också datorprogrammerad fallanalys av miljontals fall. Detta gjorde
beviset svårt att kontrollera och kontroversiellt. Beviset formaliserades och
verifierades i bevisassistenten \coq{} 1995.
%Lite mer om fyrfärgssatsen här?
%Lite mer om Odd order theorem här?

De verktyg som används vid formalisering och datorverifiering kan även användas
för att verifiera programkod. Formella metoder är således intressant för både
programmerare och matematiker. Dagens stora och komplexa programvaror skulle
kunna utnyttja formella metoder. Det kan vara användbart i kritiska system,
till exempel medicinsk utrustning, där det inte får bli fel eller i system som
inte kan uppdateras i efterhand som hårdvarunära mjukvara på ROM-minnen.

De mest använda metoderna idag för att kontrollera kod bygger på att testa om
koden ger korrekt resultat för olika indata. På detta sätt har man en chans att
upptäcka om koden innehåller fel, men det visar inte att koden saknar fel
eftersom det i många fall är omöjligt att testa alla kombinationer av indata.
% Niclas: + Svårt/Krävande att hitta kända resultat?
Formella metoder skulle i dessa fall kunna användas till att garantera
korrekthet hos koden.

Ett exempel på projekt för att verifiera kod är \textsc{CompCert}. Det
utforskar möjligheten att utveckla formellt bevisade kompilatorer. Anledningen
att man vill ha en formellt bevisad kompilator är att vid vissa optimeringar så
kan kompilatorn skapa buggar och beräkningsfel. Projektets viktigaste resultat
hittills är en fungerande C-kompilator som är bevisad i \coq{} och som stödjer
hela \textsc{ANSI C} (som är den första standardiserade versionen av
\textsc{C}) med få undantag\cite{compcert}.

Matematiska programvaror som \textsc{MATLAB} spelar en stor roll för
beräkningar inom forskning och industri och det finns därmed ett stort intresse
av att de är pålitliga. De är dock inte buggfria. Ett sätt att göra dem mer
pålitliga skulle vara att formalisera de ingående algoritmerna och visa att de
är korrekt implementerade\cite{denes2012refinement}.

\coq{} är en av flera avancerade bevisassistenter som det bedrivs aktiv
forskning om. Några andra är \textsc{Agda} som utvecklats på Chalmers.
\textsc{Z3} som har utvecklats av Microsoft och kan användas tillsammans med
flera stora ickefunktionella språk som \textsc{Python}, \textsc{C} och
\textsc{.NET}. \textsc{HOL-light} som används av Intel för att bevisa att vissa
hårdvarukomponenter fungerar korrekt och i det pågående projektet att
formalisera Keplers förmodan \cite{hales2008formal}.

Toom-Cook är en algoritm för att multiplicera heltal eller polynom. Den är
intressant eftersom den har en bättre asymptotisk tidskomplexitet än
polynommultiplikation utförd direkt enligt definitionen \footnote{För
definition av polynommultiplikation, se
appendix~\ref{app:algebra}.}, där man multiplicerar varje term i det
ena polynomet med varje term i det andra polynomet vilket har den asymptotiska
tidskomplexiteten\footnote{Funktionen $T(n)$ är $O(f(n))$ om det existerar
konstanter $c > 0$ och $n_0 \geq 0$ så att $T(n) \leq c \cdot f(n)$ för alla $n
\geq n_0$.} $\Ordo\left(n^2\right)$, där $n$ är graden på det största av de två
polynomen som skall multipliceras.

\section{Syfte}
Det här projektet går ut på att gruppdeltagarna ska lära sig formalisering med
bevisassistenten \coq{} och sedan formalisera och bevisa en matematisk algoritm,
Toom-Cook, i \coq{}.

\section{Rapportens upplägg}
I kapitel~\ref{sec:metod} beskrivs projektets arbetsmetod. I
kapitel~\ref{sec:formalisering} introduceras formalisering av matematik och
bevisassistenter. Kapitel~\ref{sec:coq} beskriver bevisassistenten \coq{} som har
använts i projektet. Kapitel~\ref{sec:toomcook} definierar algoritmen Toom-Cook och
ger ett informellt bevis för att den är korrekt. I kapitel~\ref{sec:formell}
presenteras formaliseringen och beviset av Toom-Cook i \coq{} och i
kapitel~\ref{sec:diskussion} diskuteras \coq{}, formalisering och algoritmen.

