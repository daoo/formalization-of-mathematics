I det här avsnittet ges en introduktion till \coq som språk och som
bevisassistent. \coq är ett beroenedetypat funktionellt programmeringsspråk och
\emph{interaktiv} bevisassistent som kan användas till att utveckla formella
bevis. Dessa två delar bygger på ett grundspråk, det vill säga det funktionella
språket som inte är helt olikt \textsc{Haskell}, samt ett \emph{taktikspråk}
som används för att skriva bevis.

Program och bevis som är skrivna i \coq går att exportera till programspråken
Haskell, \textsc{OCaml} and \textsc{Scheme} vilket gör att man kan skriva och
bevisa de mest kritiska delarna i ett program i \coq och sedan exportera dem
och köra dem tillsammas med icke bevisad kod i till exempel \textsc{Haskell}.

\section{Beroendetypning}
För att förklara beroendetypning använder vi begreppen \emph{termer} och
\emph{typer}. Förenklat sett kan man se termer som värden och funktioner, och
en typ kan man se som en samling, eller mängd, värden eller termer, notera att
all termer har en typ. Som ett exempel ska vi nu gå igenom hur ett funktionellt
programmerings språk med beroendetypning kan vara uppbyggt.

\subsection{Termer som beror på termer}
Den grundläggande idén med funktionell programmering är att \emph{termer kan
bero på termer}. I ett teoretiskt funktionellt språk skulle det kunna innebära
att givet någon typ, låt oss använda de naturliga talen $\mathbb{N}$ i det här
exemplet, skulle man kunna skriva
\begin{align*}
  &compose : (\mathbb{N} \to \mathbb{N}) \to (\mathbb{N} \to \mathbb{N}) \to \mathbb{N} \to \mathbb{N} \\
  &compose\ f\ g\ x = f\ (g\ x)
\end{align*}
där termerna $f$, $g$ och $h$ är funktioner och termen $x$ är ett värde. Här
säger man att termen $h$ beror på termerna $f$, $g$ och $x$. Funktionen
$compose$ definerar förstås funktionskomposition, oftast noterad med en cirkel
likt $(f \circ g)\ x$, som många lyfter fram som en viktig del av funktionell
programmering.

\subsection{Termer som beror på typer}
Utöver termer som beror på termer kan man även lägga till \emph{termer som
beror på typer}, vilket är vad som egentligen menas med polymorfism. För att
bygga vidare på vårt exempel skulle det kunna se ut såhär:
\begin{align*}
  &compose' : (b \to c) \to (a \to b) \to a \to c \\
  &compose'\ f\ g\ x = f\ (g\ x)
\end{align*}
Här har vi istället för att använda typen $\mathbb{N}$ använt de godtyckliga
typerna $a$, $b$ och $c$. Det låter oss med samma definition av $compose'$
anropa funktionen med termer av olika typer.

Ytterligare ett exempel på polymorfism är \emph{polymorfiska typer}. Låt
\begin{align*}
  &\boldsymbol{data}\ List\ a\ \boldsymbol{where} \\
  &\ \ Nil : List\ a \\
  &\ \ Cons : a \to List\ a \to List\ a
\end{align*}
Här definierar en polymorfisk datatyp för listor som vi sedan kan använda för
att lista vilken typ vi vill.

\subsection{Typer som beror på typer}
Nästa steg i utvecklingen är att låta \emph{typer bero på typer}. Med denna
funktionaliteten kan man definiera så kallade typoperatorer. Typoperatorer är
funktioner som tar in typer som parametrar och ger ut typer som resultat, till
skillnad från vanliga funktioner som tar in termer som parametrar och ger ut
termer som resultat.
% TODO: Exempel på typoperator

\subsection{Typer som beror på termer}
Det sista steget i byggandet är att lägga till \emph{typer som beror på
termer}, även känt som beroendetypning. Beroendetypning innebär väldigt
förenklat att man på typnivå kan använda samma funktioner och värden som man
kan använda på termnivå. Detta låter oss till exempel definiera vektorer, det
vill säga listor fast med en bestämd längd. Detta gör vi genom att lägga till
en parameter som representerar vektorns längd i typen och öka denna med ett när
vi lägger till ett element.
\begin{align*}
  &\boldsymbol{data}\ Vector\ a\ (n \in \mathbb{N})\ \boldsymbol{where} \\
  &\ \ Empty : Vector\ a\ 0 \\
  &\ \ Element : a \to (m \in \mathbb{N}) \to Vector\ a\ m \to Vector\ a\ (m+1)
\end{align*}
Sedan kan vi ge typen till funktioner som till exempel att slå ihop två
vektorer:
\begin{align*}
  concatenate : Vector\ a\ n \to Vector\ a\ m \to Vector\ a\ (n+m)
\end{align*}
eller ta bort första element från en vektor och ger tillbaka ``svansen'':
\begin{align*}
  tail : (n \in \mathbb{N}) \to Vector\ a\ n \to Vector\ a\ (n-1)
\end{align*}
Notera att denna funktionen inte fungerar på tomma vektorer eftersom man inte
kan ta bort ett element som inte finns, kompilatorn kan kontrollera detta
eftersom $(n-1)$ där $n=0$ inte är definierat för naturliga tal.

Värt att notera är att inte bara funktionella språk som har beroendetypade
funktioner. Ett exempel på beroendetypning som de flesta antagligen är bekanta
med är \texttt{printf} i \textsc{C}. Här bestäms antalet parametrar i funktionen
av antalet \% -tecken i den första strängen och vilken typ det ska vara på
dessa parametrar bestäms av vilken bokstav som står efter \%-tecknet.
\begin{verbatim}
printf("%s is %d years old and %f.1cm long", name, age, lenght)
\end{verbatim}
Dock stödjer typsystemet i \textsc{C} inte beroendetypning vilket gör att
kompilatorer generellt sett inte kan typchecka \texttt{printf} funktionen.

% http://mattam.org/research/publications/Programming_with_Dependent_Types_in_Coq-PPS-260209.pdf

\section{Grundspråk}
\coq är uppbyggt av två olika programmeringsspråk. Grundspråket som kallas
\textsc{Gallina} är som vi redan nämnt funktionellt och beroendetypat. Likt
andra programmeringsspråk definierar man funktioner och deras typ. Dock är det
i \coq inte tillåtet att definiera funktioner som inte terminerar. Det vill
säga, i \textsc{Haskell} kan man skriva
\begin{verbatim}
loop :: Integer -> Integer
loop n = loop (n + 1)
\end{verbatim}
och kompilatorn kommer glatt kompilera och låta dig köra funktionen. Men
\verb+loop+ kommer aldrig ge något resultat och kommer snurra i all evighet.
Kompilatorn till \coq tillåter inte denna typen av definitioner utan kommer
ge kompileringsfel om den stöter på liknande funktioner.

För att göra en definition i \coq skriver använder man nyckelordet
\C{Definition}, en definition av funktionskomposition kan se ut såhär:
\begin{lstlisting}
  Definition compose (a b c: Type) (f: b -> c) (g: a -> b) (x: a) : c := f (g x).
\end{lstlisting}
I definitionen av \C{compose} måste vi först ge typerna \C{a}, \C{b} och \C{c}
explicit till skillnad från \textsc{Haskell} där de är definierade implicit.
Parametrarna \C{f}, \C{g} och \C{x} följer sedan direkt. I \coq används punkt
(.) för att avsluta en definition likt hur man avslutar ett påstående
(\emph{engelska: statement}) i C med semikolon (;). För att anropa \C{compose}
måste man ge typer och funktioner och värdet. Till exempel:
\begin{lstlisting}
Definition add1 (x: nat) := x + 1.
Definition mul2 (x: nat) := x * 2.

Definition example : nat := compose nat nat nat add1 mul2 5.
\end{lstlisting}
Notera att programmerare är lata och vill gärna skriva så lite som möjligt. I
\coq kan man därför se till att typ parametrarna \C{a}, \C{b} och \C{c}
automatiskt stoppas in på rätt ställe i funktionsanroppen. För att göra detta
behöver man dock ändra på definitionen av \C{compose} och sätta
klammerparenteser runt parametrarna istället:
\begin{lstlisting}
Definition compose' {a b c: Type} (f: b -> c) (g: a -> b) (x: a) : c := f (g x).
\end{lstlisting}
Vi kan även använda så kallade lambdauttryck, vilket betyder funktioner
definierade utan namn som används direkt där man skriver dem. Syntaxen för
lambdauttryck är \C{fun parameters => application}. Med dessa förändringar kan
vi skriva
\begin{lstlisting}
Definition exempel' : nat := compose' (fun x => x + 1) (fun x => x * 2) 5.
\end{lstlisting}
\coq har även data typer och de definieras med hjälp av \C{Inductive}. En definition
av naturliga tal kan se ut såhär:
\begin{lstlisting}
Inductive nat : Type :=
  | O: nat
  | S: nat -> nat.
\end{lstlisting}
Typen för varje konstruktor måste ges explicit. Vi kan även definiera vektorer, för
att blanda in lite beroendetypning:
\begin{lstlisting}
Inductive vec (X: Type) : nat -> Type :=
  | empty: vec X O
  | element: forall n, X -> vec X n -> vec X (S n).
\end{lstlisting}
% Notera att jag har fuskat här och inte tagit med Implicit Argument raderna
% som behövs för att man inte ska behöva ange typerna hela tiden.
Sedan kan vi definiera en typsäker version av \C{tail} med hjälp av
mönstermatchning:
\begin{lstlisting}
Definition tail (X: Type) (n: nat) (v: vec X (S n)) : vec X n :=
  match v with
  | element X _ xs => xs
  end.
\end{lstlisting}
Mönstermatchning innebär att man för något värde tillhörande någon typ
bestämmer vad som ska göras för varje konstruktor till typen. Notera i det här
fallet att funktionen bara är definierad för vektorer \C{vec X n} där \C{n >
0}. Vi behöver således inte hantera tomma vektorer i mönstermatchningen.

För att göra en rekursiv funktion använder vi \C{Fixpoint} istället för
\C{Definition}:
\begin{lstlisting}
Fixpoint concatenate (X: Type) {n m: nat} (a: vec X n) (b: vec X m) : vec X (n+m) :=
  match a with
  | empty => b
  | element _ x xs => element x (concatenate X xs b)
  end.
\end{lstlisting}

Detta var en väldigt kort introduktion till \coq som funktionellt
programmeringsspråk och har därför utelämnat bland annat modulhantering,
typklasser, kanoniska strukturer, poster, partiell applicering och notationer.
Dessa ämnen är också viktiga för att förstå \coq men är bortom målet med denna
rapporten.
% TODO: Out of scope of this report

\section{Taktikspråk}
\coq innehåller också ett taktikspråk som heter \textsc{Ltac} och innehåller
olika taktiker för att påverka de hypoteser och mål som ska bevisas.
\textsc{Ltac} gör det möjligt att använda samma metoder i \coq som man använder
när man skapar ett pappersbevis. Då \coq är en interaktiv teorembevisare så när
en viss taktik används uppdateras de hypoteser och mål som ska bevisas och
användaren anger då en ny taktik och detta fortsätter tills alla målen är
lösta.
