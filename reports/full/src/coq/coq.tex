\section{Coq}

\subsection{Logik (Konstruktiv)}
Tror att det är bättre om någon från matte gör det här

\subsection{Curry-Howard isomorphism}
Enligt Curry Howard isomorpismen så är propositioner samma sak som typer och
bevis är samma sak som program. Om vi tar en närmare titt på
funktionsdefinitionen $a \rightarrow b$ så kan vi tolka det som att givet ett
bevis för a så får vi ett bevis för b.
\begin{align*}
  Propotioner &= Typer \\
  Bevis       &= Programs
\end{align*}

\subsection{Polymorphism}
En kort och enkel förklaring till polymorphism är att en funktion kan appliceras
på flera olika typer av parametrar.
En korrektare förklaring till polymorphism är att en polymorpisk funktion
består av två olika delfunktioner. Den första av dessa funktioner tar
typer som parametrar och returnerar den andra delfunktionen vars parametertyper
beror på parametrarna i den första funktionen.
\begin{equation}
f_{Typer}(T_1 T_2 ... : Typer)
\rightarrow f_{Termer}((t_1 : T_1) (t_2 : T_2) ...)
\end{equation}


Som de flesta funktionella programmeringspråk så har Coq stöd för ad hoc
polymorphism som även kallas överlagring. Detta innebär att typerna i
funktionen bestämms av sammanhanget användaren behöver då aldrig ge
Typerna som parametrar till den första funktionen utan kompilatorn sköter
det.
Då coq är ett strikt typat språk används
typklasser för att beskriva vilka typer som är tillåtna.

I följande exempel defineras en lista som kan innehålla värden av alla möjliga
typer. Den undre definitionen i exemplet är en rekursiv funktion som lägger till
ett ellement i en lista. Denna funktionen är polymorphisk och fungerar alltså på
alla listor oberoende vilken typ på värden som listan innehåller.
\begin{lstlisting}
Inductive list (X:Type) : Type :=
  | nil  : list X
  | cons : X -> list X -> list X .

Fixpoint append (X:Type) (l : list X) (x : X) : list X :=
  match l with
  | nil       => cons X x (nil X)
  | cons a l' => cons X a (append l' x)
  end.
\end{lstlisting}

Om det inte skulle finnas polymorphism i \coq så skulle det inte
gå att skapa en generell listtyp utan det skulle krävas en specifik
listtyp för alla andra typer. Till exempel om vi skulle lagra heltal
i en lista så skulle det finnas en specifik heltalsliste-typ som det bara
gick att lagra heltal i.

\subsection{Beroendetyper}
I en polymorphisk funktion så kan en parameter- eller retur-typ bero på vilka
typer de tidigare parametrarna har haft. I beroendetypning så går vi ett steg
längre och låter parameter- och retur-typerna bero på värdet av en
tidigare parameter.
Nedan finns två funktionsdefinitioner där beroendetypning används.
I exemplena används en klass som heter Vector som är en lista med fast längd. I
det första exemplet så gör vi om en lista till en vektor och vektorn ska då ha
samma längd som listan. I det andra exemplet har vi en funktion som tar bort
det första ellementet från en vektor och resultatet blir då en vektor med ett
mindre ellement. I \coq notation:
\begin{verbatim}
toVector: (list : List) : Vector (lenght list)

removeFirst (v : Vector n) : Vector (n-1))
\end{verbatim}

Det är inte bara funktionella språk som det finns beroendetypade funktioner.
Ett exempel på beroendetypning som de flesta antagligen är bekanta med är
\texttt{printf} i C. Här bestäms antalet parametrar i funktionen av antalet
\% -tecken i den första strängen och vilken typ det ska vara på dessa
parametrar bestäms av vilken bokstav som står efter \%-tecknet.
\begin{verbatim}
printf("%s is %d years old and %f.1cm long", name, age, lenght)
\end{verbatim}

% http://mattam.org/research/publications/Programming_with_Dependent_Types_in_Coq-PPS-260209.pdf

\subsection{Grund och taktikspråk}
Coq består av två olika delspråk. Grundspråket kallas Gallina och liknar till
viss del OCaml. Det är i Gallina som de definitioner och funktioner som ska
bevisas skrivs.

Coq innehåller också ett taktikspråk som heter Ltac och innehåller olika
taktiker för att påverka de hypoteser och mål som ska bevisas. Ltac gör det
möjligt att använda samma metoder i Coq som man använder när man skapar ett
pappersbevis. Då \coq är en interaktiv teorembevisare så när en viss taktik
används uppdateras de hypoteser och mål som ska bevisas och användaren
anger då en ny taktik och detta fortsätter tills alla målen är lösta.