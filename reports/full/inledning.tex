Komplexiteten hos matematiska bevis har med tiden ökat markant och bevis med
penna och papper är ofta inte realiserbart. Datorer kan i dessa fall utnyttjas
som hjälpmedel för att verifiera varje logiskt steg i bevisen. Flera satser har
formaliserats och två exempel är Fyrfärgssatsen\cite{gonthier2008formal} och
Feit-Thompsons sats\cite{something}. För att bevisen ska vara korrekta har man
formaliserat all matematik som satserna beror på. Vidare gör bevisens
komplexitet även att enbart områdesexperter klarar av att granska och verifiera
bevisen. Fermats stora sats är ett exempel på detta problemet då man
rapporterade beviset som korrekt 1993 men ett fel hittades sedan 2 år
senare\cite{something}.

Formaliseringen har utvecklats ur ett område som tidigare enbart intresserat
datavetare, närmare bestämt logik. De verktyg man använder bygger på logik och
kan utöver att verifiera matematiska bevis även verifiera programkod. Formella
metoder är således intressant för programmerare och inte bara matematiker.
Dagens stora och komplexa programvaror skulle kunna utnyttja formella metoder.
Det kan också vara användbart i kritiska system som inte får gå fel eller som
inte kan uppdateras i efterhand. De metoder som används idag för att
kontrollera kod bygger på att testa om olika värden och undersöka om resultaten
är korrekta. Detta kan visa att koden innehåller fel, men inte att koden saknar
fel eftersom det är omöjligt att testa alla kombinationer av värden. Formella
metoder skulle i dessa fall kunna användas till att garantera korrekthet hos
koden.

Vårt projekt har haft som mål att studera datorassisterad formalisering och
sedan formalisera en matematisk algoritm för att få en inblick i detta
forskningsområdet.

\subsection{Bevisassistent och programmeringsspråket Coq}
Formalisering är ett aktivt forskningsområde och det finns flertalet
datorverktyg för formalisering och verifiering av formella bevis som är under
aktiv utveckling. Vi har valt att använda verktyget Coq. Coq är ett
beroenedetypat funktionellt programmeringsspråk inte helt olikt Haskell. Men
till skillnad från Haskell är Coq även en \emph{interaktiv} bevisassistent som
kan användas till att utveckla formella bevis. Viktigt att notera här är att
Coq är interaktivt, det vill säga Coq bevisar inget automatiskt utan man måste
själv styra varje logiskt steg i bevisen. Program och bevis som är skrivna i
Coq går att exportera till Haskell,OCaml and Scheme vilket gör att man kan
skriva och bevisa de mest kritiska delarna i ett program och sedan exportera det
och köra det tillsammas med icke bevisad kod i till exempel Haskell.

\subsubsection{Coq's Historia}
Don Knuth, professor på Stanford, lade grunden till det som idag kallas för
datavetenskap (eng. computer science) i enavhandling år 1968. Det skulle sedan
visa sig ta 30 år av forskning att fastställa ett rigoröst område av
programmering och algoritmer. På liknande sätt var även den rigorösa grunden av
formellbevisföring under utveckling. De största genombrotten inom
formellbevisföring gjordes dock under 1930-talet av Gentzen, Gödel och
Herbrand. På 1960-talet gjordes de första experimenten av automatisk
första-ordningens-logik genom systematisk uppräkning. 40 år senare stod Coq som
en slutprodukt efter en lång serie av projekt inom beräkningsbar logik och den
sägs representera det mest ledande programmet inom detta område.

\subsubsection{Tillämpningar}
Coq har, som redan nämnts, använts till att bevisa olika stora satser och även
en del andra programvaror. Det har skett genom stora forskningsprojekt.

\begin{itemize}

\item Fyrfärgssatsen\autocite{gonthier2008formal} säger att, givet varje möjlig
uppdelning av ett plan i sammanhängande regioner, så krävs det högst fyra
färger för att färglägga alla regionerna så att inga angränsande regioner har
samma färg. Två regioner anses vara angränsande om de delar en gemensam kant
som inte är ett hörn.

Under årens lopp har det förekommit många olika bevis och motbevis som har
bevisats vara falska och  det var först 1976 som det första korrekta beviset
kom. Stora delar av beviset var då gjorda i en dator och det gick inte att
bekräfta att dessa delar var korrekta. För att bevisa att datordelarna av
beviset var korrekta så formaliserades beviset i Coq och detta ledde till
utvecklandet av SSReflect.

\item CompCert\autocite{compcert} är ett projekt som utforskar möjligheten att
utveckla formellt bevisade kompilatorer. Anledningen att man vill ha en
formellt bevisad kompilator är att vid vissa optimeringar så kan kompilatorn
skapa buggar och beräkningsfel. Att kompilatorn är formellt bevisad innebär att
det finns ett matematiskt bevis, som kan kontrolleras genom en mekanisk check,
för att den exekverbara koden beter sig så som står föreskrivet i källkoden.
Rent konkret innebär detta att man är garanterad att den exekverbara koden inte
innehåller buggar som är skapade av kompilatorn. Detta projektet resulterade i
en fungerande C-kompilator som stödjer hela ANSI C med ett få undantag och som
faktiskt är snabbare än GCC utan några optimeringar.

\item Feit-Thompsons är en sats inom matematisk gruppteori som säger att en
ändlig grupp alltid är lösbar om dess ordning är
udda\cite{aschbacher2004status}. Denna sats bevisades av Walter Feit och John
Griggs Thompson 1963. Beviset för Feit-Thompsons sats är stort och sträcker sig
över två volymer, det är mycket material för en person att sätta sig in i och
verifiera för hand. Storleken på beviset och därmed möjligheten till någon dold
miss i beviset är en av anledningarna till varför beviset för Feit-Thompsons
sats är intressant att formalisera i Coq. I samband med formaliseringen av
beviset så har även en stor del av matematisk gruppteori verifierats.

\end{itemize}

\subsubsection{Alternativ till Coq}
Det finns många olika program och språk för att formalisera och bevisa olika
former av matematik eller logik. En sak som de flesta har gemensamt är att de
är uppbyggd på funktionella programmerings paradigmer.

\begin{itemize}
\item Agda är utvecklat på Chalmers och påminner till stor del om Haskell. Till
skillnad mot Coq så finns det inga inbyggda taktiker.  Agda är inte lika
matematiskt inriktad som Coq utan används mer till att bevisa korrekthet hos
program. En fördel med Agda är att alla Unicodetecken är tillåtna vilket gör
det enkelt att skriva sina program och bevis på samma sätt som man skulle göra
det på papper.

\item Z3 är ett språk som har utvecklats av Microsoft för att förenkla och bevisa
olika teorem. Kan användas tillsammans med flera stora ickefunktionella språk
som Python, C och .NET.

\item HOL, Högre Ordningens Logik är en av de första interaktiva teorembevisarna och
HOL-light som är en vidareutveckling av det används idag av Intel för att
bevisa att vissa hårdvarukomponenter fungerar korrekt.

\item F* är en vidareutveckling av F\# och används för att verifiera och bevisa
egenskaper hos program. En av de större skillnaderna från F\# är att F* har
stöd för beroendetyper. F* är en del av .NET vilket gör att bevis och kod som
är skriven i F* går att använda i all andra .NET språk. Stora delar av F* är
formaliserade och bevisade i Coq.
\end{itemize}

\begin{comment}
Källor och annat material
HOL http://www.cl.cam.ac.uk/~jrh13/hol-light/
Z3 http://research.microsoft.com/en-us/um/redmond/projects/z3/old/
F* http://research.microsoft.com/en-us/projects/fstar/
\end{comment}

\subsection{Multiplikation av polynom}
Vi har valt att implementera och bevisa Toom-Cook algoritmen för multiplikation
av polynom. Toom-Cook är generell och fungerar för polynom, men anledningen
till att den är intressant är att heltal är ett specialfall av polynom där
basen är känd. Vidare är Toom-Cook snabbare för väldigt stora polynom än den
multiplikationsmetoden man lär sig i grundskolan som vi kallar lång
multiplikation. Det finns även en annan algoritm för polynommultiplikation som
heter Karatsuba som också är snabbare än lång multiplikation och även enklare
än Toom-Cook. Men den är redan formaliserad av vår handledare och därför är det
mer intressant att formalisera Toom-Cook.

\subsection{Mål}
Målet med vårat projekt är således att lära oss hur man använder Coq och dess
tillägg SSReflect. Vidare skall vi också använda dessa verktyg för att
formalisera ett bevis av Toom-Cook algoritmen. Den här rapporten presenterar
våra resultat och diskuterar hur bevisassistenter kan användas.
