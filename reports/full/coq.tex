\subsection{Coq}

\subsubsection{Logik (Konstruktiv)}
Tror att det är bättre om någon från matte gör det här

\subsubsection{Curry-Howard isomorphism}
Enligt Curry Howard isomorpismen så är propositioner samma sak som typer och
bevis är samma sak som program. Om vi tar en närmare titt på
funktionsdefinitionen $a \rightarrow b$ så kan vi tolka det som att givet ett
bevis för a så får vi ett bevis för b.
Enligt Curry Howard isomorpismen så är propositioner samma sak som typer och
bevis är samma sak som program. Om vi tar en närmare titt på
funktionsdefinitionen $a \rightarrow b$ så kan vi tolka det som att givet ett
bevis för a så får vi ett bevis för b.
\begin{align*}
Propotioner &= Typer \\
Bevis &= Programs
\end{align*}

\subsubsection{Polymorphism}
En enkel förklaring till polymorphism är att en funktion kan appliceras på
flera olika typer av parametrar.
En lite mer komplicerad förklaring är att en polymorphisk funktion är uppbygd av
två olika lambda uttryck där det första har typer som parametrar och det andra
uttrycket har termer som beror av de angivna typerna som parametrar.
\begin{equation}
  \lambda_{Typer} \rightarrow (\lambda_{Termer} \rightarrow x)
  \label{polymorphsk funktion}
\end{equation}
Den yttre $\lambda$-funktionen tar en eller flera typer som parametrar och ger
tillbaks en ny $\lambda$-funktion som nu har sina parametrar bundna till de
typer som angavs i den yttre $\lambda$-funktionen.

Som de flesta funktionella programmeringspråk så har Coq stöd för ad hoc
polymorphism som även kallas överlagring. Detta innebär att typerna i
funktionen bestämms av sammanhanget. Då coq är ett strikt typat språk används
typklasser för att beskriva vilka typer som är tillåtna.
Även då Coq har fullt stöd för typklasser och överlagring så används detta inte
så mycket utan istället används kanoniska strukturer {\it (Eng Canonical
Structures)}. Kanoniska strukturer är för komplicerade för att ingå i detta
kandidatarbete men de är värda att nämnas då de ofta används för att lösa
polymorphism i Coq.

I följande exempel defineras en lista som kan innehålla värden av alla möjliga
typer. Den undre definitionen i exemplet är en rekursiv funktion som lägger till
ett ellement i en lista. Denna funktionen är polymorphisk och fungerar alltså på
alla listor oberoende vilken typ på värden som listan innehåller.
\begin{verbatim}
Inductive list (X:Type) : Type :=
  | nil  : list X
  | cons : X -> list X -> list X .

Fixpoint append (X:Type) (l : list X) (x : X) : list X :=
  match l with
  | nil       => cons X x (nil X)
  | cons a l' => cons X a (append l' x)
  end.
\end{verbatim}

\subsubsection{Beroendetyper}
I en polymorphisk funktion så kan en parametertyp bero på vilka typer de
tidigare parametrarna har haft. I beroendetypning så går vi ett steg längre och
låter typerna bero på värdet av en tidigare parameter
Funktionsdefinition för en funktion som gör om en lista till en vector. En
vector är en lista med en fix längd och när vi gör om en lista till en vector
så vill vi alltså att den resullterande vectorn har samma längd som listan.
\begin{verbatim}
toVec: {a : Type} (list : List a) : Vec a (lenght list)
\end{verbatim}

Det är inte bara funktionella språk som det finns beroendetypade funktioner.
Ett exempel på beroendetypning som de flesta antagligen är bekanta med är
\texttt{printf} i C. I funktionen \texttt{printf} beror antalet parametrar och
deras typer på värdet av den första parametern.

\begin{verbatim}
printf("%s is %d years old and %f.1cm long", name ,age , lenght)
\end{verbatim}

\begin{comment}
CoqArt
http://mattam.org/research/publications/Programming_with_Dependent_Types_in_Coq-PPS-260209.pdf
** DONE Grund och taktikspråk
   CLOSED: [2013-05-10 fre 10:41]
\end{comment}

\subsubsection{Grund och taktikspråk}
Coq består av två olika delspråk. Grundspråket kallas Gallina och liknar till
viss del OCaml. Det är i Gallina som de definitioner och funktioner som ska
bevisas skrivs.

Coq innehåller också ett taktikspråk som heter Ltac och innehåller olika
taktiker för att påverka de hypoteser och mål som ska bevisas. Ltac gör det
möjligt att använda samma metoder i Coq som man använder när man skapar ett
pappersbevis.
Coq är en interaktiv teorembevisare så när en viss taktik används uppdateras de
hypoteser och mål som ska bevisas och användaren anger då en ny taktik och
detta fortsätter tills alla målen är lösta.

\subsubsection{Extrahering av program}
Det inte går att köra program i Coq utan bara att bevisa korrektheten hos dem.
Däremot så går det att exportera program skrivna Coq till OCaml, Haskell eller
Scheme. Programmen går tyvärr inte att köra dirrekt effter extraktionen utan
den generarade koden kan behövas städas upp och viss form av initialisering kan
behövas.
